{"name":"Nibiru.js","tagline":"MC framework for node.js based on express and mongoose","body":"# Nibiru.js\r\n---\r\n\r\n[![Join the chat at https://gitter.im/denistrofimov/nibiru](https://badges.gitter.im/denistrofimov/nibiru.svg)](https://gitter.im/denistrofimov/nibiru?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nNibiru.js is MC framework for modern web applications based on express and mongoose. `M` is a model, `C` is a \r\ncontroller. That is. There is no Views. Nibiru.js focus on data model and the way it being processed by front-end. \r\nThere is no big things behind, just some rules to organize your back-end application.\r\n\r\n\r\n## Install\r\nInstall via [npm](https://www.npmjs.com/package/nibiru)\r\n```bash\r\n$ npm install --save nibiru\r\n```\r\n\r\n\r\n## Usage\r\n\r\nStart app by sending application root directory to nibiru. Nibiru.js function returns vanilla bluebird Promise\r\n\r\n```js\r\nvar path = require('path');\r\nvar nibiru = require('nibiru');\r\n\r\nnibiru(path.join(__dirname, 'app')).then(function(core){\r\n\r\n    // some additional setup\r\n\r\n}).catch(function(err){\r\n\r\n    // handle bootloading error\r\n    console.error(err);\r\n    process.exit(1);\r\n\r\n});\r\n```\r\n\r\n\r\n## App structure\r\n\r\nApplication in therms of Nibiru.js slices on Configs, Services, Models and Controllers.\r\nTypically your application directory should looks like:\r\n```\r\napp\r\n┣ config\r\n┣ controllers\r\n┣ models\r\n┗ services\r\n```\r\nAll app components must exports function that will be called on bootloading state, lets call it `loader` function\r\n```js\r\nmodule.exports = function () {\r\n    // return something useful\r\n    return {};\r\n};\r\n```\r\n\r\n\r\n### Configs\r\n\r\nConfig is config.js file placed in *app/config* directory. Loader of configs accepts single \r\nargument - app directory. This is useful for example for defining a resources path.\r\n```js\r\n/** app/config/config.js */\r\n \r\nvar path = require('path');\r\n\r\nmodule.exports = function (base) {\r\n    return {\r\n        some_file_path: path.join(base, \"path/to/file.txt\")\r\n    };\r\n};\r\n```\r\nFor handling different apps stages (develop, production), Nibiru.js bootloader looks in `process.env.mode` property \r\nfor string that indicate stage. If mode is present, bootloader will try to extend default config with config \r\nfrom *app/configs/ **mode** /config.js*\r\n\r\nThere is mandatory fields that config must contains:\r\n```\r\nmongo: {\r\n     host: \"database_host\",\r\n     user: \"database_user\",\r\n     pass: \"database_user_password\",\r\n     database: \"database_name\"\r\n},\r\nserver: {\r\n     \"port\": 7051,\r\n     \"host\": \"host\"\r\n}\r\n```\r\n\r\n\r\n### Services\r\n\r\nService is an utility peace of code that loads and stores in core. Service location is *app/services* directory. By \r\nexperience we know that utility modules often represented in more than one file, even directories. For this reasons \r\nit was necessary to integrate naming conventions: service file name must ends with *\\*service.js* or *\\*Service.js*. \r\n\r\nServices available by low-cased, underscored name without *\\*service.js* suffix. Service can be grouped in subdirectories and will \r\nbe available by dot represented path.\r\n```\r\napp\r\n┗ services\r\n    ┣ utils\r\n    ┃   ┗ MD5Service.js\r\n    ┗ FileService.js\r\n```\r\nIn example above bootloader will load two services with names 'file' and 'utils.md5' respectively.\r\n\r\nService loader accepts config argument - application config loaded in previous bootloading state.\r\n\r\n\r\n### Models\r\n\r\nModels in Nibiru.js is mongoose models. They are located in *app/models* directory. Loader of model accepts `core` argument. \r\nCore argument is in object created for component communication. Application config available on `core.config` property \r\nand services can be retrieved by \r\ncalling `core.service(name)` method.\r\n```js\r\n/** app/models/User.js */\r\n\r\nvar Schema = require('mongoose').Schema;\r\n\r\nmodule.exports = function (core) {\r\n    \r\n    return new Schema({\r\n        name: {\r\n            type: String,\r\n            default: core.config.default_name // refer to config \r\n        },\r\n        avatar: {\r\n            type: String\r\n        },\r\n        region: {\r\n            type: Schema.Types.ObjectId,\r\n            ref: 'region',\r\n            childPath: 'users'\r\n        },\r\n        type: {\r\n            type: Number,\r\n            default: 1\r\n        },\r\n        registerDate: {\r\n            type: Date,\r\n            default: core.service('utils').now // refer to now method of utils service\r\n        }\r\n    });\r\n};\r\n```\r\nBootloader automatically install [mongoose-deep-populate](https://www.npmjs.com/package/mongoose-deep-populate) plugin. \r\nAlso [mongoose-relationship](https://www.npmjs.com/package/mongoose-relationship) plugin will be installed on models \r\nwho has fields with `childPath` option. \r\n\r\nName of model sets to underscored, low-cased basename of file.\r\n\r\n\r\n### Controllers\r\n\r\nControllers are business logic containers mapped to urls that located in *app/controllers* directory. Loader of controller \r\nalso accepts core argument, but for now, models can be accessed by calling `core.model('name')` method. Loader must return \r\nobject with *method* fields. Additional controller object can contain '&#64;method' field to specify http method and '&#64;route' \r\nto specify custom route for this controller (custom route must contains :method parameter).\r\n\r\nStructure of *app/controllers* directory mapped to routes. For example this structure\r\n```\r\napp\r\n┗ controllers\r\n    ┣ files\r\n    ┃   ┣ controller.js\r\n    ┃   ┗ index.js      // index.js always points to directory contains file\r\n    ┗ files.js\r\n```\r\nwill be mapped to\r\n```\r\n/files/:method\r\n/files/controller/:method\r\n/files/:method\r\n```\r\n\r\n\r\n### Application file\r\n\r\nApp root directory must contains app.js file. Loader of app file also accepts core parameter and must return express \r\napplication.\r\n\r\nExample:\r\n```js\r\n/** app/app.js */\r\n\r\nvar express = require('express');\r\nvar logger = require('morgan');\r\nvar bodyParser = require('body-parser');\r\n\r\nmodule.exports = function (core) {\r\n\r\n    var app = express();\r\n\r\n    app.use(compression({threshold: 0}));\r\n    app.use(logger('dev'));\r\n    app.use(bodyParser.json({limit: '32mb'}));\r\n    app.use(bodyParser.urlencoded({extended: false}));\r\n    \r\n    return app; // important!\r\n};\r\n```\r\n\r\n\r\n## Bonus Track\r\n\r\nAfter bootloader finished loading models, it mount RESTful router to get base CRUD functionality. There are some routes:\r\n```\r\nGET     /api/:model_name        // get all models\r\nGET     /api/:model_name/:_id   // get model by id\r\nPOST    /api/:model_name        // create new model\r\nPUT     /api/:model_name/:_id   // update existing model\r\nDELETE  /api/:model_name/:id    // delete existing model\r\n```\r\n\r\n\r\n## So what about views?\r\n\r\nAs you can guess, there are no things that can stop you to use Views with Nibiru.js. You can use express build-in views \r\nmechanism. For little bit of aesthetics, place your views in *app/views* directory and point express to use it by calling\r\n```js\r\napp.set('views', core.base('views'));\r\n```\r\n[More info about views in express](http://expressjs.com/en/guide/using-template-engines.html) ","google":"UA-73220715-1","note":"Don't delete this file! It's used internally to help with page regeneration."}